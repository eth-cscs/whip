// TODO: license and copyright
//
// clang-format off TODO

#pragma once

#if !(defined(HWH_CUDA) || defined(HWH_HIP))
#error "HWH requires exactly one of HWH_CUDA and HWH_HIP to be defined. Neither is defined."
#endif

#if defined(HWH_CUDA) && defined(HWH_HIP)
#error "HWH requires exactly one of HWH_CUDA and HWH_HIP to be defined. Both are defined."
#endif

#if defined(HWH_CUDA)
#include <cuda_runtime.h>
#endif

#if defined(HWH_HIP)
#include <hip/hip_runtime.h>
#endif

#include <cstddef>
#include <stdexcept>

namespace hwh {
inline constexpr std::size_t version_major = @PROJECT_VERSION_MAJOR@;
inline constexpr std::size_t version_minor = @PROJECT_VERSION_MINOR@;
inline constexpr std::size_t version_patch = @PROJECT_VERSION_PATCH@;
inline constexpr const char *version_string = "@PROJECT_VERSION_MAJOR@.@PROJECT_VERSION_MINOR@.@PROJECT_VERSION_PATCH@";

@hwh_types_section@
// TODO: dim3 in namespace hwh?

@hwh_constants_section@

@hwh_errors_section@

inline const char* get_error_string(error_t error) {
#if defined(HWH_CUDA)
    return cudaGetErrorString(error);
#elif defined(HWH_HIP)
    return hipGetErrorString(error);
#endif
}

// Custom exception which wraps a CUDA/HIP error
class exception final : public std::runtime_error {
public:
  explicit exception(error_t error) : std::runtime_error(get_error_string(error)), error(error) {}
  error_t get_error() const noexcept { return error; }

private:
  error_t error;
};

// Check an error and throw an exception on failure.
inline void check_error(error_t e) {
  if (e != success) {
    throw exception(e);
  }
}

@hwh_functions_section@
} // namespace hwh

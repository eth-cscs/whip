// TODO: license and copyright
//
// clang-format off TODO

#pragma once

#if !(defined(HWH_CUDA) || defined(HWH_HIP))
#error "HWH requires exactly one of HWH_CUDA and HWH_HIP to be defined. Neither is defined."
#endif

#if defined(HWH_CUDA) && defined(HWH_HIP)
#error "HWH requires exactly one of HWH_CUDA and HWH_HIP to be defined. Both are defined."
#endif

#if defined(HWH_CUDA)
#include <cuda_runtime.h>
#endif

#if defined(HWH_HIP)
#include <hip/hip_runtime.h>
#endif

namespace hwh {
// TODO: generate
inline constexpr std::size_t version_major = 0;
inline constexpr std::size_t version_minor = 1;
inline constexpr std::size_t version_patch = 0;
inline constexpr const char *version_string = "0.1.0";

@hwh_types_section@
// TODO: dim3 in namespace hwh?

@hwh_constants_section@

@hwh_errors_section@

inline const char* get_error_string(error_t error) {
#if defined(HWH_CUDA)
    return cudaGetErrorString(error);
#elif defined(HWH_HIP)
    return hipGetErrorString(error);
#endif
}

// Custom exception which wraps a CUDA/HIP error
class exception : std::exception {
public:
  exception(error_t error) : error(error), msg(get_error_string(error)) {}
  error_t get_error() const noexcept { return error; }
  const char *what() const noexcept { return msg.c_str(); }

private:
  error_t error;
  std::string msg;
};

// Check an error and throw an exception on failure.
inline void check_error(error_t e) {
  if (e != success) {
    throw exception(e);
  }
}

@hwh_functions_section@
} // namespace hwh

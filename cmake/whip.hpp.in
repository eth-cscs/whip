// TODO: license and copyright
//
// clang-format off TODO

#pragma once

#if !(defined(WHIP_CUDA) || defined(WHIP_HIP))
#error "whip requires exactly one of WHIP_CUDA and WHIP_HIP to be defined. Neither is defined."
#endif

#if defined(WHIP_CUDA) && defined(WHIP_HIP)
#error "whip requires exactly one of WHIP_CUDA and WHIP_HIP to be defined. Both are defined."
#endif

#if defined(WHIP_CUDA)
#include <cuda_runtime.h>
#endif

#if defined(WHIP_HIP)
#include <hip/hip_runtime.h>
#endif

#include <cstddef>
#include <stdexcept>

namespace whip {
inline constexpr std::size_t version_major = @PROJECT_VERSION_MAJOR@;
inline constexpr std::size_t version_minor = @PROJECT_VERSION_MINOR@;
inline constexpr std::size_t version_patch = @PROJECT_VERSION_PATCH@;
inline constexpr const char *version_string = "@PROJECT_VERSION_MAJOR@.@PROJECT_VERSION_MINOR@.@PROJECT_VERSION_PATCH@";

@whip_types_section@
// TODO: dim3 in namespace whip?

@whip_constants_section@

@whip_errors_section@

inline const char* get_error_string(error_t error) {
#if defined(WHIP_CUDA)
    return cudaGetErrorString(error);
#elif defined(WHIP_HIP)
    return hipGetErrorString(error);
#endif
}

// Custom exception which wraps a CUDA/HIP error
class exception final : public std::runtime_error {
public:
  explicit exception(error_t error) : std::runtime_error(get_error_string(error)), error(error) {}
  error_t get_error() const noexcept { return error; }

private:
  error_t error;
};

namespace impl {
// Check an error and throw an exception on failure.
inline void check_error(error_t e) {
  if (e != success) {
    throw exception(e);
  }
}

// Check an error and throw an exception on failure, except error_not_ready.
// This is useful for query functions.
inline bool check_error_query(error_t e) {
  switch (e) {
    case success:
      return true;
    case error_not_ready:
      return false;
    default:
      throw exception(e);
  }
}
} // namespace impl

@whip_functions_section@
} // namespace whip
